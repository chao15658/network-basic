# TCP重传

#### 关注的问题：

顺序问题 ，稳重不乱

丢包问题，承诺靠谱；

连接维护，有始有终；

流量控制，把握分寸；

拥塞控制，知进知退。





发送端的缓存里是按照包的ID一个个排列的。 因为TCP协议是全双工通信协议。 所以客户端既是发送端，也是接收端。 服务器端既是接收端，也是发送端。 所以客户端既有发送端缓存，也有接收端缓存。 而服务器端既有接收端缓存，也有发送端缓存。 发送端缓存会被分为4部分。 第一部分，已经发送并且已经确认的包。 第二部分，已经发送但是尚未确认的包。 第三部分，尚未发送但是马上准备发送的包。 第四部分，尚未发送但是暂时不准备发送的包。



结构如下：

![img](https://static001.geekbang.org/resource/image/16/7b/16dcd6fb8105a1caa75887b5ffa0bd7b.jpg)

LastByteAcked发送并且已经确认的包

LastByteSent发送还未确认的包

TCP 里，接收端会给发送端报一个窗口的大小，叫 Advertised window。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。





接收端缓存结构：

第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的。

第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。

第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。



![img](https://static001.geekbang.org/resource/image/f7/a4/f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg)

MaxRcvBuffer：最大缓存的量；

LastByteRead  已经接收并且确认，并且已被应用层读取；

NextByteExpected 下一个期待读取的起始位置，已经接收了，但是还没被应用层读取的，是第一部分和第二部分的分界线。

Advertised window = MaxEvcBuffer-(（NextByteExpected -1）-LastByteRead )）

​                                    =14- （（6-1）-0）=9

其中第二部分里面，由于受到的包可能不是顺序的，会出现空挡，只有和第一部分连续的，可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了。 

发送端发送的每一个数据包，服务端都要给一个确认包（ACK）.确认它收到了。 服务端给发送端发送的确认包（ACK包）中，同时会携带一个窗口的大小。 这个窗口的大小就代表目前服务器端的处理能力。（接收端最大缓存量-接收已确认但还未被应用层读取的部分）。 这个窗口的大小也是时时刻刻在变化的，可能接收方再发送数据包4的ACK时，窗口大小为9，此时应用层的程序疯狂去接收已接收并且已确认的缓存，没准接收方再发送数据包5的ACK时，窗口的大小就变为了14了呢。



重传算法：

自适应重传

有需要重传的时候，TCP的策略是**超时间隔加倍**。**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**。**两次超时，就说明网络环境差，不宜频繁反复发送。**

快速重传

有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。

SACK

需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。例如可以发送ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是7丢了。



#### 流量控制和拥塞控制

也是通过窗口的大小来控制的，流量控制（前面的滑动窗口rwnd）是怕发送方把接收方缓存塞满，而拥塞控制（拥塞窗口cwnd)，是怕把网络塞满。

这里有一个公式 LastByteSent - LastByteAcked <= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。

于是TCP的拥塞控制主要来避免两种现象，**包丢失**和**超时重传**。一旦出现了这些现象就说明，发送速度太快了，要慢一点。

通道的容量 = 带宽 × 往返延迟。

慢启动

一条TCP连接开始，cwnd设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认cwnd加一，两个确认cwnd加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认cwnd加一，四个确认cwnd加四，于是一次能够发送八个。可以看出这是**指数性的增长**。

涨到什么时候是个头呢？有一个值ssthresh为65535个字节，当超过这个值的时候，每收到一个确认，cwnd+1。出现拥塞丢包时，ssthresh=cwnd/2 , cwnd=1重新开始慢启动。

快速重传算法

当接收端发现丢了一个中间包的时候，发送三次前一个包的ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd减半为cwnd/2，然后sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。（cwnd减为原来的一半+3，sshthresh =原来的一半）

**TCP BBR拥塞算法**。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。



#### 问题总结

我们做一个基于tcp的“物联网”应用（中国移动网络），如上面所说tcp层面已经会自动重传数据了，业务层面上还有必要再重传吗？如果是的话，业务需要多久重传一次？

--- TCP的重传是网络层面和粒度的，业务层面需要看具体业务，比如发送失败可能对端在重启，一个重启时间是1min，那就没有必要每秒都发送检测啊.

1、‘序号的起始序号随时间变化，...重复需要4个多小时’，老师这个重复时间怎么计算出来的呢？每4ms加1，如果有两个TCP链接都在这个4ms内建立，是不是就是相同的起始序列号呢。



答:序号的随时间变化，主要是为了区分同一个链接发送序号混淆的问题，两个链接的话，端口或者IP肯定都不一样了.

2、报文最大生存时间（MSL）和IP协议的路由条数（TTL）什么关系呢，报文当前耗时怎么计算？TCP层有存储相应时间？
答:都和报文生存有关，前者是时间维度的概念，后者是经过路由跳数，不是时间单位.



3、当三次握手建立连接后，每次数据交互都还会ack吗？比如建立连接后，客户端发送数据包给服务器端，服务器成功收到数据包后会发送ack给客户端么？
2、如果建立连接后，客户端和服务器端没有任何数据交互，双方也不主动关闭连接，理论上这个连接会一直存在么？
3、2基础上，如果连接一直会在，双方又没有任何数据交互，若一方突然跑路了，另一方怎么知道对方已经不在了呢？在java scoket编程中，我开发客户端与服务器端代码，双方建立连接后，不发送任何数据，当我强制关闭一端时，另一端会收到一个强制关闭异常，这是如何知道对方已经强制关闭了呢？

作者回复: 是的，每次都ack。可以有keepalive，如果不交互，两边都不想释放，那就数据结构一直占用内存，对网络没啥影响。必须是发送数据的时候，才知道跑路的事情。你所谓的强制关是怎么关？有可能还是发送了fin的



#### 错题总结

a、在OSI七层模型中，各层通信单元格式：

1.物理层----比特

2.数据链路层----帧

3.网络层-------包

4.传输层------段

5.会话层-----数据单元

6.表示层----数据单元

7.应用层----数据单元



b、各应用层协议通信端口：

**http 80**

**ftp 20/21**

**ssh 22**

**telnet 23**

**smtp 25**



c.各层设备

物理层的基本功能： 利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 在物理层实现网络互连的主要设备有中继器和HUB。在物理层使用的中间设备叫转发器。目的是加强信号强度的。

数据链路层的基本功能： 通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。在数据链路层实现网络互联的主要设备有二层交换机和网桥。

 网络层基本功能： 通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。在网络层实现网络互连的主要设备有三层交换机和路由器。

在传输层（包括传输层）以上实现网络互连的设备有网关。

d.IP首部 最小20字节，最大40字节（包含可变部分）。

![img](https://uploadfiles.nowcoder.com/images/20200207/300975041_1581005352273_33CB9F3926A64AD81EC4D1F7A63D13F0)



e.各层协议以及传输单位

![img](https://uploadfiles.nowcoder.com/images/20200804/6868944_1596526123251_04396A86C0DE00739CABA3FA8AF9F7CD)



f、子网、主机个数计算

18、Internet 上一个节点的 IP 地址为 192.168.0.1/22 ，请问这个节点所在的子网，最多能够有多少台机器？（ ）



192.168.0.1/22 其中 /22是代表二进制的子网掩码有多少个1， 子网掩码用来区分ip地址的网络号和主机号，二进制的ip地址与二进制的子网掩码与运算，与子网掩码全为1的这部分得出的是网络号，全为0的部分则是主机号，有10位主机号，那该网段中有2的10次方=1024个地址可用，**并且主机号全为0的地址代表着该网段，主机号全为1的地址代表着该网段的广播地址**，这两个地址不可以用，所以该网段的可用地址为1024－2 = 1022。



g、获取网络号、主机号

1、分别将IP地址和子网掩码对应成32位的二进制，做“与”运算得到网络地址；

2、将子网掩码取反，再与IP地址做“与”运算，得到主机号



i、ip地址划分

**A类地址中的私有地址和保留地址：** 

①10.0.0.0到10.255.255.255是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。 

 ② 127.0.0.0到127.255.255.255是保留地址，用做循环测试用的。

 **B类地址的私有地址和保留地址**  

 ① 172.16.0.0到172.31.255.255是私有地址  

 ②169.254.0.0到169.254.255.255是保留地址。

 **C类地址中的私有地址：**

192.168.0.0到192.168.255.255是私有地址